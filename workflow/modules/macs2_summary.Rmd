```{r example, echo = FALSE, eval = FALSE}
## This module requires the following to be set during preparation
# source <- "AR"
# threads <- 6
```


```{r packages}
library(tidyverse)
library(magrittr)
library(rtracklayer)
library(glue)
library(pander)
library(scales)
library(plyranges)
library(yaml)
library(ngsReports)
library(UpSetR)
library(VennDiagram)
library(cowplot)
library(rlang)
library(BiocParallel)
library(parallel)
library(Rsamtools)
library(Biostrings)
library(ggside)
library(reactable)
```

```{r remotes, results = 'hide'}
## Deal with github packages
if (!"extraChIPs" %in% rownames(installed.packages()))
  BiocManager::install("steveped/extraChIPs", ask = FALSE)
stopifnot(library(extraChIPs, logical.return = TRUE))
```

```{r options}
panderOptions("big.mark", ",")
panderOptions("missing", "")
panderOptions("table.split.table", Inf)
theme_set(
  theme_bw() +
    theme(
      plot.title = element_text(hjust = 0.5)
    )
)
register(MulticoreParam(workers = threads))
source(here::here("workflow/scripts/custom_functions.R"))
## This has been pushed to the main repo of ggside, but is not yet
## incorporated into the package. The functions are geom_*sidelabel
## Once ggside 0.2.1 is released, this can be deleted
source(here::here("workflow/scripts/geom_sidelabel.R"))
```


```{r config-paths}
config <- read_yaml(
  here::here("config", "config.yml")
)
fdr_alpha <- config$comparisons$fdr
params <- read_yaml(here::here("config", "params.yml"))
bam_path <- here::here(config$paths$bam, source)
macs2_path <- here::here("output", "macs2", source)
annotation_path <- here::here("output", "annotations")
colours <- read_rds(
  file.path(annotation_path, "colours.rds")
) %>% 
  lapply(unlist)
```

```{r read-samples}
samples <-read_tsv(file.path(macs2_path, "qc_samples.tsv"))
treat_levels <- unique(samples$treat)
n_treats <- length(treat_levels)
if (!is.null(config$comparisons$contrasts)) {
  ## Ensure levels respect those provided in contrasts
  treat_levels <- config$comparisons$contrasts %>%
    unlist() %>%
    intersect(samples$treat) %>% 
    unique()
}
rep_col <- setdiff(
  colnames(samples), c("sample", "treat", "source", "input", "label", "qc")
)
samples <- samples %>%
  unite(label, treat, !!sym(rep_col), remove = FALSE) %>%
  mutate(
    treat = factor(treat, levels = treat_levels),
    "{rep_col}" := as.factor(!!sym(rep_col))
  )
```


```{r annotations}
sq <- read_rds(file.path(annotation_path, "seqinfo.rds"))
blacklist <-  file.path(annotation_path, "blacklist.bed.gz") %>%
  import.bed(seqinfo = sq) %>%
  sort()
all_gr <- file.path(annotation_path, "all_gr.rds") %>% 
  read_rds()
genes_gr <- all_gr$gene
gene_regions <- read_rds(file.path(annotation_path, "gene_regions.rds"))
regions <- vapply(gene_regions, function(x) unique(x$region), character(1))
any_detected <- FALSE
rna_path <- here::here(config$paths$rnaseq[[source]])
rnaseq <- tibble(gene_id = character())
if (length(rna_path) > 0) {
  stopifnot(file.exists(rna_path))
  if (str_detect(rna_path, "tsv$")) rnaseq <- read_tsv(rna_path)
  if (str_detect(rna_path, "csv$")) rnaseq <- read_csv(rna_path)
  if (!"gene_id" %in% colnames(rnaseq)) stop("Supplied RNA-Seq data must contain the column 'gene_id'")
  if (nrow(rnaseq) > 0 ) any_detected <- TRUE
  genes_gr <- subset(genes_gr, gene_id %in% rnaseq$gene_id)
}
tx_col <- intersect(c("tx_id", "transcript_id"), colnames(rnaseq))
rna_gr_col <- ifelse(length(tx_col) > 0, "transcript_id", "gene_id")
rna_col <- c(tx_col, "gene_id")[[1]]
tss <- read_rds(file.path(annotation_path, "tss.rds"))
## bands_df
cb <- config$genome$build %>%
  str_to_lower() %>% 
  paste0(".cytobands") 
data(list = cb)
bands_df <- get(cb)
```

```{r bfl}
bfl <- bam_path %>%
  file.path(glue("{samples$sample}.bam")) %>%
  BamFileList() %>%
  setNames(samples$sample)
```

```{r individual-peaks}
individual_peaks <- file.path(
  macs2_path, glue("{samples$sample}_peaks.narrowPeak")
) %>%
  importPeaks(seqinfo = sq, blacklist = blacklist) %>%
  setNames(samples$sample)
```


```{r macs2-logs}
macs2_logs <- file.path(macs2_path, glue("{samples$sample}_callpeak.log")) %>%
  importNgsLogs() %>%
  dplyr::select(
    -contains("file"), -outputs, -n_reads, -alt_fragment_length
  ) %>%
  left_join(samples, by = c("name" = "sample")) %>%
  mutate(
    total_peaks = map_int(
      name,
      function(x) {
        length(individual_peaks[[x]])
      }
    )
  ) 
n_reps <- macs2_logs %>% 
  group_by(treat) %>%
  summarise(n = sum(qc == "pass"))
```

## QC {.tabset}

This section provides a simple series of visualisations to enable detection of any problematic samples.

- Library Sizes: These are the total number of alignments contained in each `bam` file, as passed to `macs2 callpeak` [@Zhang18798982]
- GC Content: Most variation in GC-content should have been identified prior to performing alignments, using common tools such as [FastQC](https://github.com/s-andrews/FastQC), MultiQC [@EwelsMultiQC2016] or `ngsReports` [@WardNgsReports2019]. However, these plots may still be informative for detection of potential sequencing issues not previously addressed
- Peaks Detected: The number of peaks detected within each individual replicate are shown here, and provide clear guidance towards any samples where the IP may have been less successful. Using the settings provided in `config.yml` (i.e. `peaks:qc:min_prop_peaks`), any replicates where the number of peaks falls below `r percent(config$peaks$qc$min_prop_peaks)` of the replicate with the highest number of peaks (i.e. the 'best' sample), **will be marked as failing QC**. Whilst most cell-line generated data-sets are consistent, organoid or solid-tissue samples are far more prone to high variability in the success of the IP step.
- Cross Correlations: Shows the cross-correlation coefficients between read positions across a series of intervals [@LunSmythCsaw2014]. Weak cross-correlations can also indicate low-quality samples. These values are also used to estimate fragment length within each sample, as the peak value of the cross-correlations
- Fraction Of Reads In Peaks (FRIP): This plot shows the proportion of the alignments which fall within peaks identified by `macs2 callpeak`, with the remainder of alignments being assumed to be background [@Landt01092012]. This can provide guidance as to the success of the IP protocol, and the common-use threshold of 1% is indicated as a horizontal line. This value is not enforced as a hard QC criteria, but may be used to manually exclude samples from the file `samples.tsv` of deemed to be appropriate.


```{r macs2-logs-individual}
emphasize.italics.rows(NULL)
any_fail <- any(macs2_logs$qc == "fail")
if (any_fail) emphasize.italics.rows(which(macs2_logs$qc == "fail"))
macs2_logs %>%
  dplyr::select(
    sample = name, label,
    total_peaks, 
    reads = n_tags_treatment, read_length = tag_length,
    fragment_length
  ) %>%
  rename_all(str_sep_to_title )%>%
  pander(
    justify = "llrrrr",
    caption = glue(
      "*Summary of results for `macs2 callpeak` on individual {source} samples.",
      "Total peaks indicates the number retained after applying the FDR ", 
      "threshold of {percent(config$peaks$macs2$fdr)} during the peak calling ", 
      "process.",
      ifelse(
        any_fail,
        glue(
          "Samples shown in italics were marked (F) for exclusion from ",
          "downstream analysis as they identified fewer than ",
          "{percent(qc_prop)} of the peaks identified in the sample returning ",
          "the maximum number of peaks."
        ),
        glue(
          "No samples were identified as failing QC based on the number of ",
          "peaks identified relative to the highest quality sample."
        )
      ),
      "Any peaks passing the FDR cutoff, but which overlapped any black-listed",
      "regions were additionally excluded. The fragment length as estimated by",
      "`macs2 predictd` is given in the final column.",
      case_when(
        all(macs2_logs$paired_end) ~
          "All input files contained paired-end reads.*",
        all(!macs2_logs$paired_end) ~
          "All input files contained single-end reads.*",
        TRUE ~
          "Input files were a mixture of paired and single-end reads*"
      ),
      .sep = " "
    )
  )
```

### Library Sizes

```{r plot-macs2-libsize-individual, fig.height=6, fig.cap = glue("*Library sizes for each {source} sample. The horizontal line indicates the mean library size for each treatment group. Any samples marked for exclusion as described above will be indicated with an (F)*")}
macs2_logs %>%
  ggplot(
    aes(label, n_tags_treatment, fill = qc)
  ) +
  geom_col(position = "dodge") +
  geom_hline(
    aes(yintercept = mn),
    data = . %>%
      group_by(treat) %>%
      summarise(mn = mean(n_tags_treatment)),
    linetype = 2,
    col = "grey"
  ) +
  facet_grid(~treat, scales = "free_x", space = "free_x") +
  scale_y_continuous(expand = expansion(c(0, 0.05)), labels = comma) +
  scale_fill_manual(values = colours$qc) +
  labs(
    x = "Sample",
    y = "Library Size",
    fill = "QC"
  ) +
  ggtitle(
    glue("{source}: Library Sizes")
  )
```

### GC Content

```{r set-yield-size}
ys <- 5e5
yieldSize(bfl) <- ys
```


```{r plot-gc-content, fig.height = 6, fig.cap = glue("*GC content for each bam file, taking the first {comma(ys)} alignments from each sample. QC status is based on the number of peaks identified (see table above)*")}
bfl %>% 
  bplapply(
    function(x){
      seq <- scanBam(x, param = ScanBamParam(what = "seq"))[[1]]$seq
      freq <- letterFrequency(seq, letters = "GC") / width(seq)
      list(freq[,1])
    }
  ) %>% 
  as_tibble() %>% 
  pivot_longer(
    cols = everything(), 
    names_to = "name",
    values_to = "freq"
  ) %>% 
  left_join(macs2_logs, by = "name") %>% 
  unnest(freq) %>% 
  ggplot(aes(label, freq, fill = qc)) +
  geom_boxplot(alpha = 0.8) +
  geom_hline(
    aes(yintercept = med),
    data = . %>% 
      group_by(treat) %>% 
      summarise(med = median(freq)),
    linetype = 2,
    colour = rgb(0.2, 0.2, 0.8)
  ) +
  facet_grid(~treat, scales = "free_x", space = "free_x") +
  scale_y_continuous(labels = percent) +
  scale_fill_manual(values = colours$qc) +
  labs(
    x = "Sample",
    y = "GC content",
    fill = "QC"
  ) +
  ggtitle(
    glue("{source}: GC Content")
  )
```


### Peaks Detected

```{r plot-macs2-peaks-individual, fig.height=6, fig.cap = glue("*Peaks identified for each {source} sample. The number of peaks passing the inclusion criteria for `macs2 callpeak` (FDR < {config$peaks$macs2$fdr}) are provided. The number of retained peaks required for inclusion is shown for each treatment as the dashed grey line, with any samples marked for exclusion marked with an F.*")}
suppressWarnings(
  macs2_logs %>%
    ggplot(
      aes(label, total_peaks, fill = qc)
    ) +
    geom_col() +
    geom_label(
      aes(x = label, y = total_peaks, label = lab, colour = qc),
      data = . %>%
        mutate(
          lab = comma(total_peaks, accuracy = 1),
          total = total_peaks
        ),
      inherit.aes = FALSE,
      show.legend = FALSE
    ) +
    geom_hline(
      aes(yintercept = min),
      data = . %>%
        group_by(treat) %>%
        summarise(min = config$peaks$qc$min_prop_peaks*max(total_peaks)),
      linetype = 2,
      col = "grey"
    ) +
    facet_grid(~treat, scales = "free_x", space = "free_x") +
    scale_y_continuous(expand = expansion(c(0, 0.05)), labels = comma) +
    scale_fill_manual(values = colours$qc) +
    scale_colour_manual(values = colours$qc) +
    labs(
      x = "Sample",
      y = "Total Peaks",
      fill = "QC"
    ) +
    ggtitle(
      glue("{source}: Number of Peaks")
    )
)
```

### Cross Correlations

```{r plot_correlation, fig.height=6, fig.cap = glue("*Cross Correlaton between alignments up to 1kb apart. The dashed, grey, vertical line is the fragment length estimated by `macs2 callpeak` for each sample. For speed, only the first 5 chromosomes were used for sample-specific estimates.*")}
file.path(macs2_path, "cross_correlations.tsv") %>% 
  read_tsv() %>% 
  left_join(samples, by = "sample") %>% 
  ggplot(aes(fl, correlation, colour = treat)) +
  geom_point(alpha = 0.1) +
  geom_smooth(se = FALSE, method = 'gam', formula = y ~ s(x, bs = "cs")) +
  geom_vline(
    aes(xintercept = fragment_length),
    data = macs2_logs,
    colour = "grey40", linetype = 2
  ) +
  facet_grid(as.formula(paste("treat ~", rep_col))) +
  scale_colour_manual(values = colours$treat[treat_levels]) +
  scale_x_continuous(
    breaks = seq(0, 5*max(macs2_logs$fragment_length), by = 200)
  ) +
  labs(
    x = "Distance (bp)",
    y = "Cross Correlation",
    colour = "Treat"
  ) +
  ggtitle(
    glue("{source}: Cross Correlations")
  )
```


### FRIP

```{r plot-frip, fig.height=6, fig.cap = glue("*Fraction of Reads In Peaks for each sample. Higher values indicate more reads specifically associated with a successful IP step. The common-use minimum value for an acceptable sample (1%) is shown as a dashed horizontal line*")}
samples$sample %>%
  bplapply(
    function(x) {
      gr <- individual_peaks[[x]]
      rip <- 0
      if (length(gr) > 0) {
        sbp <- ScanBamParam(which = gr)
        rip <- sum(countBam(bfl[[x]], param = sbp)$records)
      }
      tibble(
        name = x,
        reads_in_peaks = rip
      )
    }
  ) %>%
  bind_rows() %>%
  left_join(macs2_logs, by = "name") %>%
  mutate(
    frip = reads_in_peaks / n_tags_treatment
  ) %>%
  ggplot(
    aes(label, frip, fill = qc)
  ) +
  geom_col() +
  geom_hline(yintercept = 0.01, colour = "grey", linetype = 2) +
  facet_grid(~treat, scales = "free_x", space = "free") +
  scale_y_continuous(labels = percent, expand = expansion(c(0, 0.05))) +
  scale_fill_manual(values = colours$qc) +
  labs(
    x = "Sample",
    y = "Fraction of Reads In Peaks",
    fill = "QC"
  ) +
  ggtitle(
    glue("{source}: Fraction Of Reads In Peaks")
  )
```


## Results 

### Oracle Peaks {.tabset}

```{r oracle-peaks}
oracle_peaks <- treat_levels %>%
  sapply(
    function(x) {
      gr <- file.path(macs2_path, glue("{x}_merged_peaks.narrowPeak")) %>%
        importPeaks(seqinfo = sq, blacklist = blacklist) %>% 
        unlist()
      k <- dplyr::filter(n_reps, treat == x)$n * config$peaks$qc$min_prop_reps
      if (k > 0) {
        samp <- dplyr::filter(macs2_logs, treat == x, qc != "fail")$name
        gr$n_reps <- countOverlaps(gr, individual_peaks[samp]) 
        gr$keep <- gr$n_reps > k
      } else {
        gr <- GRanges(seqinfo = sq)
      }
      gr
    },
    simplify = FALSE
  ) %>%
  GRangesList() 
consensus_peaks <- oracle_peaks %>%
  unlist() %>%
  subset(keep) %>%
  mutate(peak_position = start + peak) %>% 
  reduceMC() %>% 
  setNames(as.character(.)) %>% 
  mutate(
    score = vapply(score, max, numeric(1)),
    signalValue = vapply(signalValue, max, numeric(1)),
    pValue = vapply(pValue, max, numeric(1)),
    qValue = vapply(qValue, max, numeric(1)),
    n_reps = vapply(n_reps, sum, integer(1)),
    peak = round(vapply(peak_position, median, numeric(1)) - start, 0),
    region = bestOverlap(
      ., 
      lapply(gene_regions, select, region) %>% 
        GRangesList() %>% 
        unlist(),
      var = "region"
    ) %>% 
      factor(levels = regions)
  ) %>% 
  select(-keep, -peak_position)
```

A set of treatment-specific `r source` *oracle peaks* was defined for each condition by comparing the peaks detected when merging all treatment-specific samples, against those detected within each replicate.
Replicates which failed the previous QC steps are omitted from this step.
Oracle peaks which overlapped a peak in more than `r percent(config$peaks$qc$min_prop_reps)` of the *individual replicates passing QC*, were retained.

```{r tab-oracle-peak}
oracle_peaks %>%
  lapply(mutate, w = width) %>% 
  lapply(as_tibble) %>% 
  bind_rows(.id = "treat") %>% 
  mutate(treat = factor(treat, levels = treat_levels)) %>% 
  group_by(treat) %>% 
  summarise(
    detected_peaks = dplyr::n(),
    retained = sum(keep),
    `% retained` = percent(retained / detected_peaks, 0.1),
    median_width = median(w)
  ) %>% 
  rename_all(str_sep_to_title) %>% 
  dplyr::rename(`% Retained` = ` Retained`) %>% 
  pander(
    justify = "lrrrr",
    caption = glue(
      "Oracle peaks detected by merging samples within each treatment group.",
      "Peaks were only retained if detected in at least",
      "{percent(config$peaks$qc$min_prop_reps)} of the retained samples for each", 
      "treatment group, as described above.",
      .sep = " "
    )
  )
```

#### Peak Widths

```{r plot-peak-widths, fig.height=6, fig.cap = "Widths of all Oracle Peaks as a function of the number of replicates the peak was detected in. The y-axis is shown on the log scale."}
oracle_peaks %>%
  lapply(mutate, w = width) %>%
  lapply(as_tibble) %>%
  bind_rows(.id = "treat") %>%
  dplyr::filter(keep) %>%
  ggplot(aes(as.factor(n_reps), w, fill = treat)) +
  geom_boxplot(alpha = 0.8) +
  scale_y_log10() +
  scale_fill_manual(values = colours$treat[treat_levels]) +
  labs(x = "Replicates", y = "Peak Width", fill = "Treatment")
```


### Consensus Peaks {.tabset}

In addition to the oracle peaks, a set of `r comma(length(consensus_peaks))` treatment-agnostic `r source` H3K27ac **consensus peaks** were defined.
Consensus ranges were the *union* of all overlapping ranges defined and retained in one or more sets of oracle peaks.
Resulting values for the `score`, `signalValue`, `pValue` and `qValue` were calculated as the *maximum* across all treatments.
*Peak summits* were taken as the median position of all summits which comprise the consensus peak.
The number of replicates generating each peak was defined as the total across all treatment groups.

#### `r ifelse(length(treat_levels) <= 3, "Venn Diagram", "Upset Plot")`

```{r plot-common-peaks, results = 'hide', echo = length(treat_levels) <= 3}
fig_path <- here::here("docs", "assets", source)
if (!dir.exists(fig_path)) dir.create(fig_path, recursive = TRUE)
fig_name <- glue("{source}_common_peaks.png")
## An empty file to keep snakemake happy if > 3 treatments
file.create(file.path(fig_path, fig_name)) 
if (length(treat_levels) <= 3) {
  vd <- oracle_peaks %>%
    lapply(
      function(x) {
        names(
          subsetByOverlaps(
            consensus_peaks, 
            subset(x, keep)
          )
        )
      }
    ) %>%
    setNames(treat_levels) %>%
    venn.diagram(
      filename = file.path(fig_path, fig_name),
      imagetype = "png",
      units = "in",
      cat.cex = 1.4,
      height = 9, 
      width = 10,
      fill = colours$treat[treat_levels],
      alpha = 0.3
    )
  file.remove(list.files(fig_path, pattern = "log$", full.names = TRUE))
}
```

`r ifelse(length(treat_levels) <= 3, glue("![*Number of {source} H3K27ac consensus peaks which overlap oracle peaks defined within each condition.*](assets/{source}/{source}_common_peaks.png)"), "")`

```{r plot-common-upset, eval = length(treat_levels) > 3, echo = length(treat_levels) > 3, fig.height = 7, fig.cap = glue("*Number of {source} H3K27ac consensus peaks which overlap the oracle peaks defined within each condition.*")}
oracle_peaks %>%
  lapply(
    function(x) {
        names(
          subsetByOverlaps(
            consensus_peaks, 
            subset(x, keep)
          )
        )
    }
  ) %>%
  setNames(treat_levels) %>%
  fromList() %>%
  upset(
    sets = treat_levels,
    keep.order = TRUE,
    order.by = "freq",
    sets.bar.color = colours$treat[treat_levels],
    set_size.show = TRUE,
    set_size.scale_max = nrow(.) * 1.2,
    text.scale = 1.2
  )
```



#### Gene-Centric Regions

```{r plot-region-overlap, fig.height=8, fig.width=8, fig.cap = glue("*Proportions of {source} consensus peaks which overlap gene-centric features.*")}
consensus_peaks %>% 
  plotPie(fill = "region") +
  scale_fill_manual(
    values = colours$regions %>%
      setNames(regions[names(.)])
  ) +
  theme(legend.position = "none")
```

`r if (any_detected) "#### Detected Genes"`


 
## Highly Ranked Peaks {.tabset}

```{r grl-to-plot}
grl_to_plot <- vector("list", length(treat_levels) + 1) %>%
  setNames(c("consensus", treat_levels))
grl_to_plot$consensus <- consensus_peaks %>%
  as_tibble() %>%
  arrange(desc(score)) %>%
  dplyr::slice(1) %>%
  colToRanges("range", seqinfo = sq)
grl_to_plot[treat_levels] <- treat_levels %>% 
  lapply(
    function(x) {
      if (length(oracle_peaks[[x]]) == 0) return(NULL)
      oracle_peaks[[x]] %>% 
        filter(keep) %>% 
        filter_by_non_overlaps(
          unlist(oracle_peaks[setdiff(treat_levels, x)])
        ) %>% 
        filter_by_non_overlaps(grl_to_plot$consensus) %>% 
        as_tibble() %>% 
        arrange(desc(score)) %>% 
        dplyr::slice(1) %>% 
        colToRanges("range", seqinfo = sq)
    }
  )
grl_to_plot <- grl_to_plot %>% 
  .[vapply(., length, integer(1)) > 0] %>% 
  lapply(setNames, NULL) %>% 
  GRangesList() %>% 
  unlist() %>% 
  distinctMC(.keep_all = TRUE) %>% 
  splitAsList(names(.)) %>% 
  endoapply(function(x) x[1,]) %>% 
  .[intersect(c("consensus", treat_levels), names(.))]
```

```{r prepare-plot-objects}
## The coverage
bwfl <- file.path(macs2_path, glue("{treat_levels}_merged_treat_pileup.bw")) %>% 
  BigWigFileList() %>% 
  setNames(treat_levels)
line_col <- colours$treat[names(bwfl)]
y_lim <- file.path(
  macs2_path, glue("{treat_levels}_merged_treat_pileup.summary")
) %>% 
  setNames(treat_levels) %>% 
  lapply(read_tsv) %>% 
  lapply(pull, "score") %>% 
  lapply(max) %>% 
  lapply(c, 0) %>% 
  lapply(sort) %>% 
  unlist() %>% 
  range()

## The features track
feat_gr <- gene_regions %>% 
  lapply(granges) %>% 
  GRangesList()
feature_colours <- colours$regions

## The genes track
hfgc_genes <- read_rds(
  here::here("output", "annotations", "trans_models.rds")
)
gene_col <- "grey"
if (any_detected){
  rna_lfc_col <- colnames(rnaseq)[str_detect(str_to_lower(colnames(rnaseq)), "logfc")][1]
  rna_fdr_col <- colnames(rnaseq)[str_detect(str_to_lower(colnames(rnaseq)), "fdr|adjp")][1]
  if (!is.na(rna_lfc_col) & !is.na(rna_fdr_col)) {
    hfgc_genes <- hfgc_genes %>%
      mutate(
        status = case_when(
          !gene %in% rnaseq$gene_id ~ "Undetected",
          gene %in% dplyr::filter(
            rnaseq, !!sym(rna_lfc_col) > 0, !!sym(rna_fdr_col) < fdr_alpha
          )$gene_id ~ "Up",
          gene %in% dplyr::filter(
            rnaseq, !!sym(rna_lfc_col) < 0, !!sym(rna_fdr_col) < fdr_alpha
          )$gene_id ~ "Down",
          gene %in% dplyr::filter(
            rnaseq, !!sym(rna_fdr_col) >= fdr_alpha
          )$gene_id ~ "Unchanged",
        )
      ) %>%
      splitAsList(.$status) %>%
      lapply(select, -status) %>%
      GRangesList()
    gene_col <- colours$direction %>%
      setNames(str_to_title(names(.)))
  }
}
```

Coverage for a small set of highly ranked peaks are shown below.
These are the most highly ranked Consensus Peak (by `score`) and any oracle peaks which are unique to each treatment group, after excluding the most highly ranked consensus peak.
The limits of the y-axis are set to be constant across all plots for easier comparability between peaks.

```{r plot-highly-ranked}
htmltools::tagList(
  mclapply(
    seq_along(grl_to_plot),
    function(x) {
      nm <- names(grl_to_plot)[[x]]
      ## Export the png
      png_out <- file.path(
        fig_path,
        nm %>% 
          str_replace_all(" ", "_") %>% 
          paste0("_topranked.png")
      )
      png(
        filename = png_out,
        width = knitr::opts_current$get("fig.width"), 
        height = knitr::opts_current$get("fig.height"), 
        units = "in", res = 300
      )
      ## Automatically collapse Transcripts if more than 10
      ct <- FALSE
      gh <- 1
      if (length(subsetByOverlaps(all_gr$transcript, grl_to_plot[[x]])) > 20) {
        ct <- "meta"
        gh <- 0.5
      }
      ## Generate the plot
      plotHFGC(
        grl_to_plot[[x]],
        features = feat_gr, featcol = feature_colours,
        genes = hfgc_genes, genecol = gene_col,
        coverage = bwfl, linecol = line_col,
        cytobands = bands_df,
        rotation.title = 90,
        zoom = 20,
        ylim = y_lim, # Needs fixing in plotHFGC
        collapseTranscripts = ct, genesize = gh,
        col.title = "black", background.title = "white", 
        showAxis = FALSE
      )
      dev.off()
      
      ## Define the caption
      gr <- join_nearest(grl_to_plot[[x]], all_gr$gene, distance = TRUE)
      d <- gr$distance
      gn <- gr$gene_name
      peak_desc <- ifelse(
        nm == "consensus",
        "consensus peak by combined score across all treatments.",
        paste(
          "oracle-peak unique to the merged", nm, "samples."
        )
      )
      cp <- htmltools::tags$em(
        glue(
          "The most highly ranked {peak_desc} ",
          ifelse(
            d == 0,
            paste('The peak directly overlaps', gn),
            paste0("The nearest gene was ", gn, ", ", round(d/1e3, 1), "kb away")
          ),
          ifelse(
            any_detected & gn %in% genes_gr$gene_name,
            glue(" which was detected in the RNA-Seq data."),
            glue(".")
          )
        )
      )
      
      ## Create html tags
      fig_link <- str_extract(png_out, "assets.+")
      htmltools::div(
        htmltools::div(
          id = nm %>% 
            str_replace_all(" ", "-") %>% 
            str_to_lower() %>% 
            paste0("-topranked"),
          class="section level3",
          htmltools::h3(
            ifelse(
              nm == "consensus",
              "Consensus Peaks",
              paste("Oracle Peaks:", nm)
            )
          ),
          htmltools::div(
            class = "figure", style = "text-align: center",
            htmltools::img(src = fig_link, width = 960),
            htmltools::p(
              class = "caption", htmltools::tags$em(cp)
            )
          )
        )
      )
    },
    mc.cores = min(length(grl_to_plot), threads)
  )
)  
```


## Feature Classification

As these peaks generally represent active regulatory regions, peaks were first classified into 1) promoters (i.e. those overlapping a previously identified promoter) and 2) enhancers (all other peaks).
Enhancers were then further stratified into Super Enhancers and Enhancers, using the ROSE algorithm.

```{r tab-region-overlap}
df <- gene_regions %>% 
  mclapply(
    function(x) {
      x <- mutate(x, marked = overlapsAny(x, consensus_peaks))
      x$detected <- FALSE
      if (rna_col %in% names(mcols(x))) {
        x$detected <- vapply(
          x$gene_id, function(id) any(id %in% rnaseq$gene_id), logical(1)
        )
      }
      x
    },
    mc.cores = length(gene_regions)
  ) %>% 
  lapply(as_tibble) %>% 
  lapply(select, region, marked, detected) %>% 
  bind_rows(.id = "name") %>% 
  mutate(name = factor(name, levels = names(gene_regions))) %>% 
  group_by(name, region) %>% 
  summarise(
    n = dplyr::n(),
    marked_detected = sum(marked & detected),
    marked = sum(marked),
    detected = sum(detected),
    .groups = "drop"
  ) %>% 
  mutate(
    `% marked` = marked / n,
    `% detected` = detected / n,
    `% marked detected` = marked_detected / marked
  ) %>% 
  dplyr::select(
    region, n, marked, `% marked`, detected, `% detected`, everything()
  )
htmltools::tags$caption(
  htmltools::em(
    glue(
      "
      Summary of all previously defined gene-centric regions and which contain 
      an H3K27ac peak. Any genes associated with the region are also defined
      as detected if RNA-Seq data is provided and the gene is present. 
      The number of regions overlapping an H3K27ac peak and associated with a
      detected gene are given in the final two columns
      "
    )
  )
)
df %>% 
  reactable(
    searchable = FALSE, filterable = FALSE,
    columns = list(
      region = colDef(name = "Region", maxWidth = 150),
      n = colDef(
        name = "Total", format = colFormat(separators = TRUE),
        maxWidth = 100
      ),
      marked = colDef(
        name = "Overlaps H3K27ac Peak",
        format = colFormat(separators = TRUE),
        maxWidth = 120
      ),
      `% marked` = colDef(
        name = "% H3K27ac Overlap",
        format = colFormat(percent = TRUE, digits = 1),
        maxWidth = 120
      ),
      detected = colDef(
        name = "Gene Detected",
        format = colFormat(separators = TRUE),
        maxWidth = 120
      ),
      `% detected` = colDef(
        name = "% Detected",
        format = colFormat(percent = TRUE, digits = 1),
        maxWidth = 120
      ),
      marked_detected = colDef(
        name = "H3K27ac & Detected",
        format = colFormat(separators = TRUE),
        maxWidth = 120
      ),
      `% marked detected` = colDef(
        name = "% H3K27ac & Detected",
        format =  colFormat(percent = TRUE, digits = 1),
        maxWidth = 120
      ),
      name = colDef(show = FALSE)
    )
  )
```


### Promoters & Enhancers

```{r dist-to-tss, fig.height=6, fig.cap = glue("*Distance from each peak to the nearest TSS. Vertical lines indicate the distance from any TSS considered to be a Promoter during annotation setup ({max(unlist(params$gene_regions$promoters))/1e3}kb).*")}
a <- consensus_peaks %>% 
  join_nearest(
    mutate(tss, tss = start)
  ) %>% 
  mutate(d = start + width/2 - tss) %>% 
  mcols() %>% 
  as.data.frame() %>%
  ggplot(aes(d / 1e3)) +
  geom_density() +
  geom_vline(
    xintercept = c(-1, 1) * max(unlist(params$gene_regions$promoters)) / 1e3,
    linetype = 2, colour = "grey40"
  ) +
  coord_cartesian(xlim = c(-100, 100)) +
  labs(
    x = "Distance to Nearest TSS (kb)",
    y = "Density"
  )
b <- consensus_peaks %>% 
  join_nearest(
    mutate(tss, tss = start)
  ) %>% 
  mutate(d = start + width/2 - tss) %>%
  as.data.frame() %>% 
  select(d) %>% 
  arrange(abs(d)) %>% 
  mutate(
    q = seq_along(d) / nrow(.)
  ) %>% 
  ggplot(aes(abs(d) / 1e3, q)) +
  geom_line() +
  geom_vline(
    xintercept = max(unlist(params$gene_regions$promoters)) / 1e3, 
    linetype = 2, colour = "grey40"
  ) +
  coord_cartesian(xlim = c(0, 100)) +
  labs(
    x = "Distance to Nearest TSS (kb)",
    y = "Quantile"
  ) +
  scale_y_continuous(labels = percent, breaks = seq(0, 1, by = 0.2)) +
  scale_x_continuous(breaks = seq(0, 100, by = 20))
plot_grid(a, b, labels = c("A", "B"))
```

```{r define-prom-enh}
prom <- consensus_peaks %>% 
  subsetByOverlaps(
    subset(
      gene_regions$promoters, 
      vapply(gene_id, function(x) any(x %in% genes_gr$gene_id), logical(1))
    )
  )
enh <- filter_by_non_overlaps(consensus_peaks, prom)
```

Any peak which overlapped the promoter in the range `r str_extract(regions[["promoters"]], "-[0-9]+/\\+[0-9]+")`bp around the TSS was considered to denote a promoter.
If RNA-seq data was supplied, these promoters were restricted to those associated with a detected gene.
All other peaks were considered to be enhancers.
Whilst relatively crude, splitting of large peaks into constituent regions which are acting as promoters or enhancer may yield less information than hoped for.
This gave a total of `r comma(length(prom))` H3K27ac-defined promoters and `r comma(length(enh))` H3K27ac-defined Enhancers

## Super-Enhancer Detection

In order to classify the enhancers with the highest signal as Super-Enhancers, the ROSE model [@WhyteRose] was use to classify the strongest as putative super-enhancers.
All treatment conditions were merged taking the complete dataset as the source of H3K27ac signal.

### Steps of the ROSE Algorithm (Super Enhancers) {.tabset}

The steps are as follows:

1. Remove any regions which overlap a TSS and set aside as promoters
    + TSS regions are extended by `r params$gene_regions$promoters$upstream/1e3`kb upstream and `r params$gene_regions$promoters$downstream`bp downstream to give a broader `r sum(unlist(params$gene_regions$promoters))/1e3`kb TSS/promoter region, however **the size of the H3K27ac peaks effectively defines the promoter**
2. Join any remaining candidate enhancers within 12.5kb
    + Remove any candidate regions shorter than 1kb as these will not make the cut. Leaving these regions in the data will also significantly decrease the power of the algorithm.
3. Count reads aligned within each region to get the number of reads
    + Alignments were pre-filtered such that only reads with a `MAPQ` score > 10 were retained
    + Strandedness of aligned reads was not taken into account
4. Counts are transformed into Reads Per Million (`RPM`) by dividing by the total number of reads aligned within each bam file, divided by 10^-6^
5. `RPM` values within each region are divided by the region width to give `RPM/BP`
6. `RPM/BP` values are then background corrected by subtracting the values observed in the control sample
    + Any `RPM/BP` < 0 are automatically set to 0 when calculating the cutoff
7. Candidate enhancers are then ranked and the point found for which the slope of the tangent line drops below 1

Unlike other implementations of ROSE, standard Bioconductor data structures will be used.
Additionally, the functions `calculate_cutoff()` and `numPts_below_line()` were taken directly from the main [ROSE github software repository](https://github.com/rakarnik/ROSE/blob/master/ROSE_callSuper.R)
RPM/BP Values were averaged across all samples

```{r form-rpmpbp}
candidate_se <- stitchRanges(enh, exclude = gene_regions$promoters) %>% 
  subset(width > 1e3)
libSizes <- bfl %>%
  lapply(idxstatsBam) %>%
  lapply(pull, "mapped") %>%
  vapply(sum, numeric(1)) %>%
  ## Remove reads from the blacklisted regions
  magrittr::subtract(
    vapply(
      bfl, 
      function(x){
        sum(countBam(x, param = ScanBamParam(which = blacklist))$records)
      }, 
      numeric(1)
    )
  ) %>%
  divide_by(1e6) %>% 
  setNames(paste0(names(.), ".bam"))
ip_bam <- BamFileList(
  here::here(config$paths$bam, "Input", glue(unique(samples$input), ".bam"))
)
ip_lib <- lapply(ip_bam, idxstatsBam) %>% 
  lapply(pull, "mapped") %>% 
  vapply(sum, numeric(1)) %>%
  ## Remove reads from the blacklisted regions
  magrittr::subtract(
    vapply(
      ip_bam, 
      function(x){
        sum(countBam(x, param = ScanBamParam(which = blacklist))$records)
      }, 
      numeric(1)
    )
  ) %>%
  divide_by(1e6) 
rpmpbp <- bfl %>%
  countBam(param = ScanBamParam(which = candidate_se)) %>%
  mutate(
    rpmpbp = (records / libSizes[file]) / width
  ) %>% 
  left_join(
    ip_bam %>% 
      countBam(param = ScanBamParam(which = candidate_se)) %>% 
      group_by(space, start, end, width) %>% 
      mutate(libsize = ip_lib[file]) %>% 
      summarise(input = sum(records / libSizes / width), .groups = "drop"),
    by = c("space", "start", "end", "width")
  ) %>% 
  mutate(rpmpbp = rpmpbp - input) %>% 
  group_by(space, start, end, width) %>% 
  summarise(rpmpbp = sum(rpmpbp), .groups = "drop") %>% 
  dplyr::filter(rpmpbp > 0) %>% 
  as_tibble()
```

### Enhancer Width Vs Signal

```{r plot-width-rpmpbp, fig.width=8, fig.height=6, fig.cap = "*Relationship between merged peak width and Reads Per Million per Base Pair.*"}
rpmpbp %>%
  ggplot(aes(width/1e3, rpmpbp)) +
  geom_point() +
  geom_smooth(se = FALSE) +
  labs(x = "Width (kb)", y = "RPM/BP") +
  scale_x_log10() 
```

### ROSE Cutoff Plot

```{r plotRose, fig.height=6, fig.width=8, fig.cap="Super-Enhancer Detection Using ROSE"}
calculate_cutoff <- function(inputVector, drawPlot=TRUE,...){
  inputVector <- sort(inputVector)
  inputVector[inputVector<0]<-0 #set those regions with more control than ranking equal to zero
  slope <- (max(inputVector)-min(inputVector))/length(inputVector) #This is the slope of the line we want to slide. This is the diagonal.
  xPt <- floor(optimize(numPts_below_line,lower=1,upper=length(inputVector),myVector= inputVector,slope=slope)$minimum) #Find the x-axis point where a line passing through that point has the minimum number of points below it. (ie. tangent)
  y_cutoff <- inputVector[xPt] #The y-value at this x point. This is our cutoff.
  
  if(drawPlot){  #if TRUE, draw the plot
    plot(1:length(inputVector), inputVector,type="l",...)
    b <- y_cutoff-(slope* xPt)
    abline(v= xPt,h= y_cutoff,lty=2,col=8)
    points(xPt,y_cutoff,pch=16,cex=0.9,col=2)
    abline(coef=c(b,slope),col=2)
    text(x = 0.25*length(inputVector), y = 0.9*max(inputVector), labels = paste("x=",xPt,"\ny=",signif(y_cutoff,3),"\nFold over Median=",signif(y_cutoff/median(inputVector),3),"x\nFold over Mean=",signif(y_cutoff/mean(inputVector),3),"x",sep=""))
    axis(1,sum(inputVector==0),sum(inputVector==0),col.axis="pink",col="pink") #Number of regions with zero signal
  }
  return(list(absolute=y_cutoff,overMedian=y_cutoff/median(inputVector),overMean=y_cutoff/mean(inputVector)))
}
numPts_below_line <- function(myVector,slope,x){
  yPt <- myVector[x]
  b <- yPt-(slope*x)
  xPts <- 1:length(myVector)
  return(sum(myVector<=(xPts*slope+b)))
}
cuts <- calculate_cutoff(rpmpbp$rpmpbp, main = source, ylab = "H3K27Ac Signal (RPM/BP)", xlab = "Rank") %>% 
  as_tibble() 
se <- rpmpbp %>% 
  dplyr::filter(rpmpbp > cuts$absolute) %>% 
  makeGRangesFromDataFrame(
    seqnames.field = "space", keep.extra.columns = TRUE, seqinfo = sq
  )
```

During preparation the original `r comma(length(enh))` enahncers were merged into `r comma(length(candidate_se))` regions, with widths ranging from 1 to `r round(max(width(candidate_se))/1e3, 1)`kb.
After running ROSE, `r comma(length(se))` putative super-enhancers were detected.

### The Highest Signal Super-Enhancer

```{r plot-se1, fig.cap = "*H3K27ac signal for the region with the largest overall signal. The region classed as a putative super-enhancer is highlighted in blue*"}
plotHFGC(
  se %>% filter(rpmpbp == max(rpmpbp)),
  features = feat_gr, featcol = feature_colours,
  genes = hfgc_genes, genecol = gene_col,
  coverage = bwfl, linecol = line_col,
  cytobands = bands_df,
  rotation.title = 90,
  zoom = 10,
  ylim = y_lim, # Needs fixing in plotHFGC
  collapseTranscripts = "meta", genesize = 1,
  col.title = "black", background.title = "white", 
  showAxis = FALSE
)
```

### Confidence Intervals By Chromosome

```{r plot-se-confint, fig.cap = "*95% FWER-adjusted Confidence Intervals for the probability of all candidate regions being considered as a super-enhancer by chromosome. Any pair of intervals which do not overlap indicates a possible enrichment for super-enhancer activity on one chromosome. Potential genomic duplication events may also be an unaddressed factor underlying any high signal levels.*"}
candidate_se %>% 
  mutate(se = overlapsAny(., se)) %>%
  as_tibble(rangeAsChar = FALSE) %>% 
  with(glm(se ~ 0 + seqnames, family = "binomial")) %>% 
  glht() %>% 
  confint() %>% 
  .[["confint"]] %>% 
  as_tibble(rownames = "chr") %>%
  mutate(
    chr = str_remove(chr, "seqnames") %>% factor(levels = seqlevels(sq)), 
    across(all_of(c("Estimate", "lwr", "upr")), binomial()$linkinv)
  ) %>%
  ggplot(aes(Estimate, fct_rev(chr))) + 
  geom_point() + 
  geom_errorbarh(aes(xmin = lwr, xmax = upr)) +
  labs(
    x = "Probability of A Candidate Region Being Classed as a Super-Enhancer",
    y = "Chromosome"
  )
```


### The Widest Super-Enhancer

```{r plot-se2, fig.cap= "*H3K27ac signal for the widest region passing the ROSE criteria for inclusion as a super-enhancer.*"}
plotHFGC(
  se %>% filter(width == max(width)) %>% .[1],
  features = feat_gr, featcol = feature_colours,
  genes = hfgc_genes, genecol = gene_col,
  coverage = bwfl, linecol = line_col,
  cytobands = bands_df,
  rotation.title = 90,
  zoom = 10,
  ylim = y_lim, # Needs fixing in plotHFGC
  collapseTranscripts = "meta", genesize = 1,
  col.title = "black", background.title = "white", 
  showAxis = FALSE
)
```


## Data Export


```{r export, results='hide'}
all_out <- list(
  consensus_peaks_bed = file.path(macs2_path, "consensus_peaks.bed"),
  oracle_peaks_rds = file.path(macs2_path, "oracle_peaks.rds"),
  promoters = file.path(macs2_path, glue("{source}_promoters.bed")),
  enhancers = file.path(macs2_path, glue("{source}_enhancers.bed")),
  gtf = file.path(macs2_path, glue(source, "_h3k27ac_features.gtf")),
  renv = file.path(
    here::here("output/envs"), 
    glue("{source}_macs2_summary.RData")
  )
) %>% 
  c(
    sapply(
      names(oracle_peaks), 
      function(x) {
        file.path(macs2_path, glue("{x}_oracle_peaks.bed"))
      },
      simplify = FALSE
    ) %>% 
      setNames(
        glue("{names(.)}_oracle_peaks_bed")
      )
  )
export(consensus_peaks, all_out$consensus_peaks)
oracle_peaks %>%
  lapply(subset, keep) %>%
  lapply(select, -keep) %>%
  GRangesList() %>%
  write_rds(all_out$oracle_peaks, compress = "gz")
names(oracle_peaks) %>% 
  lapply(
    function(x) {
      id <- glue("{x}_oracle_peaks_bed")
      oracle_peaks[[x]] %>% 
        subset(keep) %>% 
        select(score, signalValue, pValue, qValue, peak) %>% 
        export(all_out[[id]], format = "narrowPeak")
    }
  )
if (!dir.exists(dirname(all_out$renv))) dir.create(dirname(all_out$renv))
save.image(all_out$renv)
export.bed(prom, all_out$promoters)
export.bed(enh, all_out$enhancers)
GRangesList(
  promoter = granges(prom),
  enhancer = granges(filter_by_non_overlaps(enh, se)),
  super_enhancer = granges(se)
) %>% 
  endoapply(setNames, NULL) %>% 
  unlist() %>% 
  sort() %>% 
  names_to_column("feature") %>% 
  export.gff(all_out$gtf)
```

During this workflow the following files were exported:

`r pander(lapply(all_out, str_extract, pattern = "output.+"))`

## References

<div id="refs"></div>

<br>
<button type="button" class="btn btn-default btn-sessioninfo" data-toggle="collapse" data-source="#sessioninfo" style="display: block;">
<span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span> Session information
</button>
</p>
<div id="sessioninfo" class="collapse">
```{r session-info, echo=FALSE}
pander::pander(sessionInfo())
```
</div>
